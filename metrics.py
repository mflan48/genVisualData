"""
A set of calculations of AFD and other typical & extendable eye-tracking metrics
"""

import pandas as pd
import numpy as np
import subprocess
from math import sqrt
from scipy.io import savemat

"""
A calculation of AFD (in ms) for a DataFrame of the same form as createCombinedDF.
    Each fixation is processed independently of AOIs

    data: a pandas DataFrame, as generated by createCombinedDf.
    
    period: For a multi-period calculation, specify the number of milleseconds of each period.
        Results will be returned as a list. If period is zero, the average will be taken for the 
        whole DataFrame.
"""
def get_global_afd(data, subdivision=1):
    if subdivision is 0 or subdivision is 1:
        return data["fix_dur"].mean()
    else:
        first_time = data["fix_time"].iloc[0]
        last_time = data["fix_time"].iloc[-1]
        times = np.linspace(float(first_time), float(last_time), num=int(subdivision)+1)

        means = list()

        for i in range(len(times)-1):
            time_1, time_2 = times[i: i+2]
            in_range_cond = np.logical_and(data["fix_time"] >= time_1,
                                           data["fix_time"] < time_2)
            means.append(data.loc[in_range_cond, "fix_dur"].mean())

        return means

"""
Get the AFD for each AOI.
"""
def get_aoi_afd(data):
    unique_aois = data.function.unique()
    aoi_afd = dict()

    for aoi in unique_aois:
        aoi_data = data[data.function == aoi]
        aoi_afd[aoi] = aoi_data["fix_dur"].mean()

    return aoi_afd

"""
Get total fixation count
"""
def get_fixation_count(data):
    return len(data)

"""
Get total fixation count on a particular AOI
"""
def get_aoi_fixation_count(data, func_name):
    return len(data[data.function == func_name])

"""
Get average saccade length
"""
def get_avg_saccade_length(data):
    rows = list(data.iterrows())
    saccade_lengths = list()

    for i in range(len(rows) - 1):
        this_row, next_row = rows[i][1], rows[i+1][1]
        x_diff, y_diff = next_row.pixel_x - this_row.pixel_x, next_row.pixel_y - this_row.pixel_y
        saccade_lengths.append(sqrt(x_diff ** 2 + y_diff ** 2))

    return np.array(saccade_lengths).mean()


"""
Find the time at which some number of fixations on any target area have occurred.

Input: a DataFrame and a list of target functions that match a possible
    name in the DataFrame's 'function' field
"""
def detect_on_target_focus(data, target_functions, num_required):
    sequence = list(data['function'])
    times = list(data['fix_time'])
    found_loc = None

    for i in range(len(sequence) - num_required):
        if any(sequence[i: i+num_required] == [target] * num_required
               for target in target_functions):
            found_loc = i
            break

    return times[found_loc]

"""
------------ The following is likely to be deprecated. ---------------
"""

"""
Convert the dataframe to a time series and resample it.

time_step_size MUST be a valid pandas frequency string:
    https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects
"""
def resample(data, time_step_size):
    return data.resample(time_step_size).ffill()


"""
Transforms a pair of string sequences into a pair of integer sequences,
    by mapping each unique string to a number.
"""
def to_numeric_codes(seq1, seq2):
    seq_combined = seq1 + seq2
    str_to_num = dict()
    count = 1

    for item in seq_combined:
        if item not in str_to_num.keys():
            str_to_num[item] = count
            count += 1

    num_seq1, num_seq2 = list(), list()

    for item in seq1:
        num_seq1.append(str_to_num[item])

    for item in seq2:
        num_seq2.append(str_to_num[item])

    return num_seq1, num_seq2


"""
Creates a combined pandas DataFrame from a set of CSV files,
excluding the 'AOI' column.

Input: a list of CSV files
Output: a combined DataFrame with (at least) the following fields:
    ['fix_col', 'fix_line', 'fix_time', 'fix_dur' (milliseconds), 'which_file', 'function']
"""
def create_functions_df(csv_files):
    series = [pd.read_csv(
                  csv_file, parse_dates=["fix_time"], index_col=["fix_time"]
              )
              for csv_file in csv_files]

    combined_series = pd.concat(series, ignore_index=False)

    combined_series = combined_series.sort_index()

    return combined_series


"""
Input: Two dataframes containing fixation data.

Effect: Resample the data and run the wrapper for MATLAB nwalign.

Note: time_step_size MUST be a valid pandas frequency string:
    https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects
    
This only works on Linux at the moment.
"""
def scanmatch(data_1, data_2, time_step_size):
    # Create a pandas time series and resample
    data_1 = resample(data_1, time_step_size)
    data_2 = resample(data_2, time_step_size)

    string_seq_1 = list(data_1["function"])
    string_seq_2 = list(data_2["function"])

    int_seq_1, int_seq_2 = to_numeric_codes(string_seq_1, string_seq_2)

    # Save integer sequences to a .MAT file as seq1 and seq2
    savemat(
        "sequences.mat",
        {
            "seq1": int_seq_1,
            "seq2": int_seq_2
        }
    )

    # Run compare_paths.m
    result = subprocess.check_output(
        ['matlab', '-wait', '-nosplash', '-nodesktop', '-nodisplay', '-nojvm',
         '-r', "wrap_nwAlgo"]
    )

    return float(result)
